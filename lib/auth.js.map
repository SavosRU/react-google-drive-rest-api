{"version":3,"sources":["../src/auth.es6"],"names":["base64url","axios","crypto","require","JWT","Auth","constructor","token","isInited","init","iss","private_key","server_client_id","id","priv_key","getServerClientId","getJWT","time_stamp","_getTimeStampInSecond","Date","getTime","timeStamp","jwt_claim","JSON","stringify","Sign","createSign","write","HEADER","end","sig","sign","getAccessToken","success_callback","fail_callback","checkIfTokenValid","Promise","resolve","isSuccess","status","data","access_token","jwt","post","validateStatus","then","response","_handleResponse","catch","err","console","error","time_stamp_in_ms","Math","floor"],"mappings":"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","file":"auth.js","sourcesContent":["import base64url from \"base64url\";\nimport axios from 'axios';\nconst crypto = require('crypto-browserify');\nimport { JWT } from './config.es6';\n\nclass Auth {\n  constructor() {\n    this.token = null;\n    this.isInited = false;\n  }\n\n  init({ iss, private_key, server_client_id }) {\n    if (iss && private_key && server_client_id) {\n      this.id = server_client_id;\n      // your server account email\n      this.iss = iss;\n      //private key obtained from the Google API Console: https://console.developers.google.com/\n      this.priv_key = private_key;\n      this.isInited = true;\n    }\n\n  }\n\n  getServerClientId() { return this.id }\n\n  isInited() { return this.isInited }\n  /** ============================================================================\n   *                              OAuth 2.0\n   *  ============================================================================*/\n\n  getJWT() {\n    // generate time stamp for JWT claim\n    let time_stamp = this._getTimeStampInSecond(new Date().getTime())\n    this.timeStamp = time_stamp;\n    //JWT part 2: claim\n    let jwt_claim = base64url(JSON.stringify({\n      \"iss\": this.iss,\n      \"scope\": \"https://www.googleapis.com/auth/drive\", //TO DO: specify scope for each request\n      \"aud\": \"https://www.googleapis.com/oauth2/v4/token\",\n      \"exp\": time_stamp + 3600,\n      \"iat\": time_stamp\n    }));\n\n    //JWT part 3: sign for the JWT\n    // TODO: FIX BUG: write after end\n    const Sign = crypto.createSign('RSA-SHA256');\n    Sign.write(JWT.HEADER + \".\" + jwt_claim);\n    Sign.end();\n\n    // JWT part 3': signature\n    let sig = base64url(Sign.sign(this.priv_key));\n\n    /**\n     * return full JWT that has been signed and is ready for transmission\n     *  the JWT should look like: \n     *    {Base64url encoded header}.{Base64url encoded claim set}.{Base64url encoded signature}   \n     */\n    return JWT.HEADER + \".\" + jwt_claim + \".\" + sig;\n  }\n\n  // get service account access token by JWT\n  getAccessToken(success_callback, fail_callback) {\n    if (this.checkIfTokenValid()) return new Promise(resolve => resolve({ isSuccess: true, status: 'use existed token', data: { access_token: this.token } }));\n    // refresh the JWT\n    let jwt = this.getJWT();\n\n    // refer to Google developer document: https://developers.google.com/identity/protocols/OAuth2ServiceAccount\n    return axios.post(\n      \"https://www.googleapis.com/oauth2/v4/token\",\n      'grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=' + jwt,\n      {\n        validateStatus: () => true,\n      }\n    )\n      .then(\n        response => {\n          // for security reason, access token should only save in the RAM\n          if (response.status === 200) { //console.log('access_token: ', response.data.access_token); \n            this.token = response.data.access_token;\n          }\n          // return promise\n          return { isSuccess: this._handleResponse(response, success_callback, fail_callback), status: response.status, data: response.data }\n        })\n      .catch((err) => console.error('Error when geting access token from Google \\n ----------------- \\n', err))\n  }\n\n  checkIfTokenValid() {\n    // check if this access token is timeout; if still valid, return this token\n    if (this.token && this._getTimeStampInSecond(new Date().getTime()) - this.timeStamp < 3540) {\n      //console.log('===================Use existed valid token==================\\n', this.token);\n      return true;\n    }\n    else return false;\n\n  }\n\n\n  _getTimeStampInSecond(time_stamp_in_ms) {\n    return Math.floor(time_stamp_in_ms / 1000);\n  }\n}\n\nexport default new Auth();"]}