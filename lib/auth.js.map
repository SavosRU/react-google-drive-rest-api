{"version":3,"sources":["../src/auth.es6"],"names":["crypto","require","Auth","token","isInited","iss","private_key","server_client_id","id","priv_key","time_stamp","_getTimeStampInSecond","Date","getTime","timeStamp","jwt_claim","JSON","stringify","Sign","createSign","write","JWT","HEADER","end","sig","sign","success_callback","fail_callback","checkIfTokenValid","Promise","resolve","isSuccess","status","data","access_token","jwt","getJWT","axios","post","validateStatus","then","response","_handleResponse","catch","err","console","error","time_stamp_in_ms","Math","floor"],"mappings":"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","file":"auth.js","sourcesContent":["import base64url from \"base64url\";\nimport axios from 'axios';\nconst crypto = require('crypto-browserify');\nimport { JWT } from './config';\n\nclass Auth {\n  constructor() {\n    this.token = null;\n    this.isInited = false;\n  }\n\n  init({ iss, private_key, server_client_id }) {\n    if (iss && private_key && server_client_id) {\n      this.id = server_client_id;\n      // your server account email\n      this.iss = iss;\n      //private key obtained from the Google API Console: https://console.developers.google.com/\n      this.priv_key = private_key;\n      this.isInited = true;\n    }\n\n  }\n\n  getServerClientId() { return this.id }\n\n  isInited() { return this.isInited }\n  /** ============================================================================\n   *                              OAuth 2.0\n   *  ============================================================================*/\n\n  getJWT() {\n    // generate time stamp for JWT claim\n    let time_stamp = this._getTimeStampInSecond(new Date().getTime())\n    this.timeStamp = time_stamp;\n    //JWT part 2: claim\n    let jwt_claim = base64url(JSON.stringify({\n      \"iss\": this.iss,\n      \"scope\": \"https://www.googleapis.com/auth/drive\", //TO DO: specify scope for each request\n      \"aud\": \"https://www.googleapis.com/oauth2/v4/token\",\n      \"exp\": time_stamp + 3600,\n      \"iat\": time_stamp\n    }));\n\n    //JWT part 3: sign for the JWT\n    // TODO: FIX BUG: write after end\n    const Sign = crypto.createSign('RSA-SHA256');\n    Sign.write(JWT.HEADER + \".\" + jwt_claim);\n    Sign.end();\n\n    // JWT part 3': signature\n    let sig = base64url(Sign.sign(this.priv_key));\n\n    /**\n     * return full JWT that has been signed and is ready for transmission\n     *  the JWT should look like: \n     *    {Base64url encoded header}.{Base64url encoded claim set}.{Base64url encoded signature}   \n     */\n    return JWT.HEADER + \".\" + jwt_claim + \".\" + sig;\n  }\n\n  // get service account access token by JWT\n  getAccessToken(success_callback, fail_callback) {\n    if (this.checkIfTokenValid()) return new Promise(resolve => resolve({ isSuccess: true, status: 'use existed token', data: { access_token: this.token } }));\n    // refresh the JWT\n    let jwt = this.getJWT();\n\n    // refer to Google developer document: https://developers.google.com/identity/protocols/OAuth2ServiceAccount\n    return axios.post(\n      \"https://www.googleapis.com/oauth2/v4/token\",\n      'grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=' + jwt,\n      {\n        validateStatus: () => true,\n      }\n    )\n      .then(\n        response => {\n          // for security reason, access token should only save in the RAM\n          if (response.status === 200) { //console.log('access_token: ', response.data.access_token); \n            this.token = response.data.access_token;\n          }\n          // return promise\n          return { isSuccess: this._handleResponse(response, success_callback, fail_callback), status: response.status, data: response.data }\n        })\n      .catch((err) => console.error('Error when geting access token from Google \\n ----------------- \\n', err))\n  }\n\n  checkIfTokenValid() {\n    // check if this access token is timeout; if still valid, return this token\n    if (this.token && this._getTimeStampInSecond(new Date().getTime()) - this.timeStamp < 3540) {\n      //console.log('===================Use existed valid token==================\\n', this.token);\n      return true;\n    }\n    else return false;\n\n  }\n\n\n  _getTimeStampInSecond(time_stamp_in_ms) {\n    return Math.floor(time_stamp_in_ms / 1000);\n  }\n}\n\nexport default new Auth();"]}